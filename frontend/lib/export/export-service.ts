/**
 * ExportService for Next.js — Adapted from src/services/ExportService.ts
 * Handles PDF, XLSX, DOCX generation server-side.
 */
import { jsPDF } from "jspdf";
import ExcelJS from "exceljs";
import {
    Document,
    Packer,
    Paragraph,
    TextRun,
    HeadingLevel,
    AlignmentType,
    Header,
    Footer,
    PageNumber,
    BorderStyle,
    Table,
    TableRow,
    TableCell,
    WidthType,
} from "docx";

// ─── Types ─────────────────────────────────────────────────

export interface ExportOptions {
    title?: string;
    confidence?: number;
    provider?: string;
    processedAt?: string;
    sheetName?: string;
}

// ─── ExportService ─────────────────────────────────────────

export class ExportService {
    private static readonly BRAND = "OCR Universe";

    // ═══════════════════════════════════════════════════
    // 1. PDF — jsPDF with header/footer
    // ═══════════════════════════════════════════════════

    static toPDF(content: string, options: ExportOptions = {}): Buffer {
        const {
            title = "OCR Result",
            confidence,
            provider,
            processedAt = new Date().toISOString(),
        } = options;

        const doc = new jsPDF({ orientation: "portrait", unit: "mm", format: "a4" });
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const margin = 20;
        const contentWidth = pageWidth - margin * 2;

        // Header bar
        doc.setFillColor(29, 78, 216);
        doc.rect(0, 0, pageWidth, 18, "F");
        doc.setFont("helvetica", "bold");
        doc.setFontSize(11);
        doc.setTextColor(255, 255, 255);
        doc.text(this.BRAND, margin, 12);
        doc.setFont("helvetica", "normal");
        doc.setFontSize(8);
        doc.text(new Date(processedAt).toLocaleString("vi-VN"), pageWidth - margin, 12, { align: "right" });

        // Title
        let y = 28;
        doc.setFont("helvetica", "bold");
        doc.setFontSize(16);
        doc.setTextColor(17, 24, 39);
        doc.text(title, margin, y);
        y += 8;

        // Stats
        if (confidence !== undefined) {
            doc.setFont("helvetica", "normal");
            doc.setFontSize(9);
            doc.setTextColor(107, 114, 128);
            const stats = [`Confidence: ${confidence.toFixed(1)}%`, provider ? `Provider: ${provider}` : null].filter(Boolean).join("  |  ");
            doc.text(stats, margin, y);
            y += 4;
        }

        // Divider
        y += 2;
        doc.setDrawColor(229, 231, 235);
        doc.setLineWidth(0.3);
        doc.line(margin, y, pageWidth - margin, y);
        y += 8;

        // Body
        doc.setFont("helvetica", "normal");
        doc.setFontSize(10);
        doc.setTextColor(31, 41, 55);
        const lines = doc.splitTextToSize(content, contentWidth);
        const lineHeight = 5;

        for (const line of lines) {
            if (y + lineHeight > pageHeight - 20) {
                this.pdfFooter(doc, pageWidth, pageHeight, margin);
                doc.addPage();
                y = 20;
            }
            doc.text(line, margin, y);
            y += lineHeight;
        }

        this.pdfFooter(doc, pageWidth, pageHeight, margin);
        return Buffer.from(doc.output("arraybuffer"));
    }

    private static pdfFooter(doc: jsPDF, pw: number, ph: number, m: number) {
        const y = ph - 10;
        doc.setDrawColor(229, 231, 235);
        doc.setLineWidth(0.2);
        doc.line(m, y - 3, pw - m, y - 3);
        doc.setFont("helvetica", "normal");
        doc.setFontSize(7);
        doc.setTextColor(156, 163, 175);
        doc.text(`Generated by ${this.BRAND}`, m, y);
        doc.text(`Page ${doc.internal.pages.length - 1}`, pw - m, y, { align: "right" });
    }

    // ═══════════════════════════════════════════════════
    // 2. EXCEL — ExcelJS
    // ═══════════════════════════════════════════════════

    static async toExcel(
        jsonData: Record<string, unknown> | Array<Record<string, unknown>>,
        options: ExportOptions = {}
    ): Promise<Buffer> {
        const { sheetName = "OCR Data", title = "OCR Extracted Data" } = options;

        const workbook = new ExcelJS.Workbook();
        workbook.creator = this.BRAND;
        workbook.created = new Date();
        const sheet = workbook.addWorksheet(sheetName);

        const headerFill: ExcelJS.Fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FF1D4ED8" } };
        const headerFont: Partial<ExcelJS.Font> = { bold: true, color: { argb: "FFFFFFFF" }, size: 11 };
        const border: Partial<ExcelJS.Border> = { style: "thin" as ExcelJS.BorderStyle, color: { argb: "FFE5E7EB" } };
        const borders: Partial<ExcelJS.Borders> = { top: border, bottom: border, left: border, right: border };

        if (Array.isArray(jsonData)) {
            const titleRow = sheet.addRow([title]);
            titleRow.font = { bold: true, size: 14, color: { argb: "FF1D4ED8" } };
            sheet.addRow([]);

            if (jsonData.length > 0) {
                const keys = Object.keys(jsonData[0]);
                const hr = sheet.addRow(keys);
                hr.eachCell((c) => { c.fill = headerFill; c.font = headerFont; c.border = borders; c.alignment = { vertical: "middle", horizontal: "center" }; });

                for (const item of jsonData) {
                    const r = sheet.addRow(keys.map((k) => this.flat(item[k])));
                    r.eachCell((c) => { c.border = borders; c.alignment = { vertical: "middle", wrapText: true }; });
                }
                keys.forEach((k, i) => { sheet.getColumn(i + 1).width = Math.max(15, Math.min(50, k.length + 10)); });
            }
        } else {
            const titleRow = sheet.addRow([title]);
            titleRow.font = { bold: true, size: 14, color: { argb: "FF1D4ED8" } };
            sheet.addRow([]);

            const hr = sheet.addRow(["Trường", "Giá trị"]);
            hr.eachCell((c) => { c.fill = headerFill; c.font = headerFont; c.border = borders; });

            for (const [key, value] of Object.entries(jsonData)) {
                if (key.startsWith("_")) continue;
                const r = sheet.addRow([key, this.flat(value)]);
                r.eachCell((c) => { c.border = borders; c.alignment = { vertical: "middle", wrapText: true }; });
            }
            sheet.getColumn(1).width = 25;
            sheet.getColumn(2).width = 60;
        }

        sheet.addRow([]);
        const fr = sheet.addRow([`Generated by ${this.BRAND} — ${new Date().toLocaleString("vi-VN")}`]);
        fr.font = { italic: true, size: 8, color: { argb: "FF9CA3AF" } };

        const buf = await workbook.xlsx.writeBuffer();
        return Buffer.from(buf);
    }

    private static flat(v: unknown): string {
        if (v === null || v === undefined) return "—";
        if (typeof v === "string") return v;
        if (typeof v === "number" || typeof v === "boolean") return String(v);
        if (Array.isArray(v)) return v.length === 0 ? "—" : typeof v[0] === "string" ? v.join(", ") : JSON.stringify(v, null, 2);
        return JSON.stringify(v, null, 2);
    }

    // ═══════════════════════════════════════════════════
    // 3. DOCX — docx lib
    // ═══════════════════════════════════════════════════

    static async toDocx(content: string, options: ExportOptions = {}): Promise<Buffer> {
        const {
            title = "OCR Result",
            confidence,
            provider,
            processedAt = new Date().toISOString(),
        } = options;

        const paragraphs = content.split("\n");
        const noBorder = { style: BorderStyle.NONE, size: 0, color: "FFFFFF" };
        const noBorders = { top: noBorder, bottom: noBorder, left: noBorder, right: noBorder };

        const doc = new Document({
            creator: this.BRAND,
            title,
            sections: [{
                properties: {
                    page: { margin: { top: 1440, bottom: 1440, left: 1440, right: 1440 } },
                },
                headers: {
                    default: new Header({
                        children: [new Paragraph({
                            children: [
                                new TextRun({ text: this.BRAND, bold: true, size: 18, color: "1D4ED8", font: "Arial" }),
                                new TextRun({ text: `\t\t${new Date(processedAt).toLocaleString("vi-VN")}`, size: 14, color: "9CA3AF", font: "Arial" }),
                            ],
                            border: { bottom: { style: BorderStyle.SINGLE, size: 1, color: "E5E7EB" } },
                            spacing: { after: 200 },
                        })],
                    }),
                },
                footers: {
                    default: new Footer({
                        children: [new Paragraph({
                            children: [
                                new TextRun({ text: `Generated by ${this.BRAND}`, size: 14, color: "9CA3AF", font: "Arial" }),
                                new TextRun({ children: ["\t\tPage ", PageNumber.CURRENT, " of ", PageNumber.TOTAL_PAGES], size: 14, color: "9CA3AF", font: "Arial" }),
                            ],
                            border: { top: { style: BorderStyle.SINGLE, size: 1, color: "E5E7EB" } },
                            spacing: { before: 200 },
                        })],
                    }),
                },
                children: [
                    // Title
                    new Paragraph({
                        heading: HeadingLevel.HEADING_1,
                        children: [new TextRun({ text: title, bold: true, size: 32, color: "111827", font: "Arial" })],
                        spacing: { after: 100 },
                    }),

                    // Stats
                    ...(confidence !== undefined || provider ? [
                        new Table({
                            rows: [new TableRow({
                                children: [
                                    ...(confidence !== undefined ? [new TableCell({
                                        children: [new Paragraph({ children: [new TextRun({ text: `Confidence: ${confidence.toFixed(1)}%`, size: 16, color: confidence < 80 ? "D97706" : "059669", font: "Arial" })] })],
                                        width: { size: 50, type: WidthType.PERCENTAGE },
                                        borders: noBorders,
                                    })] : []),
                                    ...(provider ? [new TableCell({
                                        children: [new Paragraph({ children: [new TextRun({ text: `Provider: ${provider}`, size: 16, color: "6B7280", font: "Arial" })], alignment: AlignmentType.RIGHT })],
                                        width: { size: 50, type: WidthType.PERCENTAGE },
                                        borders: noBorders,
                                    })] : []),
                                ],
                            })],
                            width: { size: 100, type: WidthType.PERCENTAGE },
                        }),
                        new Paragraph({ spacing: { after: 200 } }),
                    ] : []),

                    // Content — highlight «guessed» words
                    ...paragraphs.map((line) => {
                        if (!line.trim()) return new Paragraph({ spacing: { after: 100 } });

                        const children: TextRun[] = [];
                        for (const part of line.trim().split(/(«[^»]+»)/g)) {
                            if (part.startsWith("«") && part.endsWith("»")) {
                                children.push(new TextRun({
                                    text: part.slice(1, -1),
                                    color: "D97706", italics: true,
                                    underline: { type: "single", color: "D97706" },
                                    size: 22, font: "Arial",
                                }));
                            } else {
                                children.push(new TextRun({ text: part, size: 22, color: "1F2937", font: "Arial" }));
                            }
                        }
                        return new Paragraph({ children, spacing: { after: 80, line: 360 } });
                    }),
                ],
            }],
        });

        const buffer = await Packer.toBuffer(doc);
        return Buffer.from(buffer);
    }
}
