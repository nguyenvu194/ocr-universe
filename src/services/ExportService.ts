/**
 * ExportService — Xuất đa định dạng: PDF, XLSX, DOCX
 *
 * Sử dụng:
 *   - jsPDF: Tạo PDF chuyên nghiệp với header/footer hệ thống
 *   - ExcelJS: Tạo bảng tính XLSX từ dữ liệu JSON
 *   - docx: Tạo file Word giữ nguyên định dạng AI phục chế
 */
import { jsPDF } from "jspdf";
import ExcelJS from "exceljs";
import {
    Document,
    Packer,
    Paragraph,
    TextRun,
    HeadingLevel,
    AlignmentType,
    Header,
    Footer,
    PageNumber,
    NumberFormat,
    BorderStyle,
    Table,
    TableRow,
    TableCell,
    WidthType,
} from "docx";

// ─── Types ─────────────────────────────────────────────────

export interface ExportPDFOptions {
    title?: string;
    fileName?: string;
    showConfidence?: boolean;
    confidence?: number;
    provider?: string;
    processedAt?: string;
}

export interface ExportExcelOptions {
    sheetName?: string;
    fileName?: string;
    title?: string;
}

export interface ExportDocxOptions {
    title?: string;
    fileName?: string;
    confidence?: number;
    provider?: string;
    processedAt?: string;
}

// ─── ExportService ─────────────────────────────────────────

export class ExportService {
    private static readonly BRAND = "OCR Universe";
    private static readonly BRAND_COLOR = "#1d4ed8"; // blue-700
    private static readonly GRAY = "#6b7280";

    // ═══════════════════════════════════════════════════
    // 1. TO PDF — Chuyên nghiệp với header/footer
    // ═══════════════════════════════════════════════════

    /**
     * Tạo file PDF chuyên nghiệp có header/footer hệ thống.
     * @returns Buffer chứa nội dung PDF
     */
    static toPDF(content: string, options: ExportPDFOptions = {}): Buffer {
        const {
            title = "OCR Result",
            showConfidence = true,
            confidence,
            provider,
            processedAt = new Date().toISOString(),
        } = options;

        const doc = new jsPDF({
            orientation: "portrait",
            unit: "mm",
            format: "a4",
        });

        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const margin = 20;
        const contentWidth = pageWidth - margin * 2;

        // ── Header ──
        doc.setFillColor(29, 78, 216); // blue-700
        doc.rect(0, 0, pageWidth, 18, "F");

        doc.setFont("helvetica", "bold");
        doc.setFontSize(11);
        doc.setTextColor(255, 255, 255);
        doc.text(this.BRAND, margin, 12);

        doc.setFont("helvetica", "normal");
        doc.setFontSize(8);
        doc.text(`Exported: ${new Date(processedAt).toLocaleString("vi-VN")}`, pageWidth - margin, 12, {
            align: "right",
        });

        // ── Title Section ──
        let y = 28;
        doc.setFont("helvetica", "bold");
        doc.setFontSize(16);
        doc.setTextColor(17, 24, 39); // gray-900
        doc.text(title, margin, y);
        y += 8;

        // Stats line
        if (showConfidence && confidence !== undefined) {
            doc.setFont("helvetica", "normal");
            doc.setFontSize(9);
            doc.setTextColor(107, 114, 128); // gray-500
            const stats = [
                `Confidence: ${confidence.toFixed(1)}%`,
                provider ? `Provider: ${provider}` : null,
            ]
                .filter(Boolean)
                .join("  |  ");
            doc.text(stats, margin, y);
            y += 4;
        }

        // Divider
        y += 2;
        doc.setDrawColor(229, 231, 235); // gray-200
        doc.setLineWidth(0.3);
        doc.line(margin, y, pageWidth - margin, y);
        y += 8;

        // ── Body Content ──
        doc.setFont("helvetica", "normal");
        doc.setFontSize(10);
        doc.setTextColor(31, 41, 55); // gray-800

        const lines = doc.splitTextToSize(content, contentWidth);
        const lineHeight = 5;

        for (const line of lines) {
            // Page break if needed
            if (y + lineHeight > pageHeight - 20) {
                this.addPDFFooter(doc, pageWidth, pageHeight, margin);
                doc.addPage();
                y = 20;
            }
            doc.text(line, margin, y);
            y += lineHeight;
        }

        // ── Footer (last page) ──
        this.addPDFFooter(doc, pageWidth, pageHeight, margin);

        return Buffer.from(doc.output("arraybuffer"));
    }

    private static addPDFFooter(
        doc: jsPDF,
        pageWidth: number,
        pageHeight: number,
        margin: number
    ): void {
        const footerY = pageHeight - 10;

        doc.setDrawColor(229, 231, 235);
        doc.setLineWidth(0.2);
        doc.line(margin, footerY - 3, pageWidth - margin, footerY - 3);

        doc.setFont("helvetica", "normal");
        doc.setFontSize(7);
        doc.setTextColor(156, 163, 175); // gray-400

        doc.text(`Generated by ${this.BRAND}`, margin, footerY);

        const pageNum = doc.internal.pages.length - 1;
        doc.text(`Page ${pageNum}`, pageWidth - margin, footerY, { align: "right" });
    }

    // ═══════════════════════════════════════════════════
    // 2. TO EXCEL — Bảng tính XLSX từ JSON
    // ═══════════════════════════════════════════════════

    /**
     * Chuyển đổi dữ liệu JSON thành file XLSX.
     * Hỗ trợ: flat key-value, array of objects, hoặc nested data.
     * @returns Buffer chứa nội dung XLSX
     */
    static async toExcel(
        jsonData: Record<string, unknown> | Array<Record<string, unknown>>,
        options: ExportExcelOptions = {}
    ): Promise<Buffer> {
        const { sheetName = "OCR Data", title = "OCR Extracted Data" } = options;

        const workbook = new ExcelJS.Workbook();
        workbook.creator = this.BRAND;
        workbook.created = new Date();

        const sheet = workbook.addWorksheet(sheetName, {
            properties: { defaultColWidth: 25 },
        });

        // ── Styles ──
        const headerFill: ExcelJS.Fill = {
            type: "pattern",
            pattern: "solid",
            fgColor: { argb: "FF1D4ED8" }, // blue-700
        };
        const headerFont: Partial<ExcelJS.Font> = {
            bold: true,
            color: { argb: "FFFFFFFF" },
            size: 11,
        };
        const borderStyle: Partial<ExcelJS.Border> = {
            style: "thin" as ExcelJS.BorderStyle,
            color: { argb: "FFE5E7EB" },
        };
        const borders: Partial<ExcelJS.Borders> = {
            top: borderStyle,
            bottom: borderStyle,
            left: borderStyle,
            right: borderStyle,
        };

        if (Array.isArray(jsonData)) {
            // ── Array of objects → table ──
            if (jsonData.length === 0) {
                sheet.addRow(["Không có dữ liệu"]);
            } else {
                // Title row
                const titleRow = sheet.addRow([title]);
                titleRow.font = { bold: true, size: 14, color: { argb: "FF1D4ED8" } };
                sheet.addRow([]); // spacer

                // Header row
                const keys = Object.keys(jsonData[0]);
                const headerRow = sheet.addRow(keys);
                headerRow.eachCell((cell: ExcelJS.Cell) => {
                    cell.fill = headerFill;
                    cell.font = headerFont;
                    cell.border = borders;
                    cell.alignment = { vertical: "middle", horizontal: "center" };
                });

                // Data rows
                for (const item of jsonData) {
                    const row = sheet.addRow(keys.map((k) => this.flattenValue(item[k])));
                    row.eachCell((cell: ExcelJS.Cell) => {
                        cell.border = borders;
                        cell.alignment = { vertical: "middle", wrapText: true };
                    });
                }

                // Auto-fit columns
                keys.forEach((_, i) => {
                    const col = sheet.getColumn(i + 1);
                    col.width = Math.max(15, Math.min(50, (keys[i]?.length || 10) + 10));
                });
            }
        } else {
            // ── Flat key-value → two-column table ──
            const titleRow = sheet.addRow([title]);
            titleRow.font = { bold: true, size: 14, color: { argb: "FF1D4ED8" } };
            sheet.addRow([]);

            const headerRow = sheet.addRow(["Trường", "Giá trị"]);
            headerRow.eachCell((cell: ExcelJS.Cell) => {
                cell.fill = headerFill;
                cell.font = headerFont;
                cell.border = borders;
            });

            for (const [key, value] of Object.entries(jsonData)) {
                if (key.startsWith("_")) continue; // Skip internal fields
                const displayValue = this.flattenValue(value);
                const row = sheet.addRow([key, displayValue]);
                row.eachCell((cell: ExcelJS.Cell) => {
                    cell.border = borders;
                    cell.alignment = { vertical: "middle", wrapText: true };
                });
            }

            sheet.getColumn(1).width = 25;
            sheet.getColumn(2).width = 60;
        }

        // ── Footer row ──
        sheet.addRow([]);
        const footerRow = sheet.addRow([`Generated by ${this.BRAND} — ${new Date().toLocaleString("vi-VN")}`]);
        footerRow.font = { italic: true, size: 8, color: { argb: "FF9CA3AF" } };

        const buffer = await workbook.xlsx.writeBuffer();
        return Buffer.from(buffer);
    }

    private static flattenValue(value: unknown): string {
        if (value === null || value === undefined) return "—";
        if (typeof value === "string") return value;
        if (typeof value === "number" || typeof value === "boolean") return String(value);
        if (Array.isArray(value)) {
            if (value.length === 0) return "—";
            if (typeof value[0] === "string") return value.join(", ");
            return JSON.stringify(value, null, 2);
        }
        return JSON.stringify(value, null, 2);
    }

    // ═══════════════════════════════════════════════════
    // 3. TO DOCX — Giữ nguyên định dạng AI phục chế
    // ═══════════════════════════════════════════════════

    /**
     * Tạo file DOCX giữ nguyên định dạng văn bản đã được AI phục chế.
     * @returns Buffer chứa nội dung DOCX
     */
    static async toDocx(content: string, options: ExportDocxOptions = {}): Promise<Buffer> {
        const {
            title = "OCR Result",
            confidence,
            provider,
            processedAt = new Date().toISOString(),
        } = options;

        // Parse content into paragraphs
        const paragraphs = content.split("\n");

        const doc = new Document({
            creator: this.BRAND,
            title,
            description: `OCR result exported by ${this.BRAND}`,
            sections: [
                {
                    properties: {
                        page: {
                            margin: {
                                top: 1440,    // 1 inch
                                bottom: 1440,
                                left: 1440,
                                right: 1440,
                            },
                        },
                    },
                    headers: {
                        default: new Header({
                            children: [
                                new Paragraph({
                                    children: [
                                        new TextRun({
                                            text: this.BRAND,
                                            bold: true,
                                            size: 18,
                                            color: "1D4ED8",
                                            font: "Arial",
                                        }),
                                        new TextRun({
                                            text: `\t\t${new Date(processedAt).toLocaleString("vi-VN")}`,
                                            size: 14,
                                            color: "9CA3AF",
                                            font: "Arial",
                                        }),
                                    ],
                                    border: {
                                        bottom: {
                                            style: BorderStyle.SINGLE,
                                            size: 1,
                                            color: "E5E7EB",
                                        },
                                    },
                                    spacing: { after: 200 },
                                }),
                            ],
                        }),
                    },
                    footers: {
                        default: new Footer({
                            children: [
                                new Paragraph({
                                    children: [
                                        new TextRun({
                                            text: `Generated by ${this.BRAND}`,
                                            size: 14,
                                            color: "9CA3AF",
                                            font: "Arial",
                                        }),
                                        new TextRun({
                                            children: ["\t\tPage ", PageNumber.CURRENT, " of ", PageNumber.TOTAL_PAGES],
                                            size: 14,
                                            color: "9CA3AF",
                                            font: "Arial",
                                        }),
                                    ],
                                    border: {
                                        top: {
                                            style: BorderStyle.SINGLE,
                                            size: 1,
                                            color: "E5E7EB",
                                        },
                                    },
                                    spacing: { before: 200 },
                                }),
                            ],
                        }),
                    },
                    children: [
                        // Title
                        new Paragraph({
                            heading: HeadingLevel.HEADING_1,
                            children: [
                                new TextRun({
                                    text: title,
                                    bold: true,
                                    size: 32,
                                    color: "111827",
                                    font: "Arial",
                                }),
                            ],
                            spacing: { after: 100 },
                        }),

                        // Stats table
                        ...(confidence !== undefined || provider
                            ? [
                                new Table({
                                    rows: [
                                        new TableRow({
                                            children: [
                                                ...(confidence !== undefined
                                                    ? [
                                                        new TableCell({
                                                            children: [
                                                                new Paragraph({
                                                                    children: [
                                                                        new TextRun({
                                                                            text: `Confidence: ${confidence.toFixed(1)}%`,
                                                                            size: 16,
                                                                            color: confidence < 80 ? "D97706" : "059669",
                                                                            font: "Arial",
                                                                        }),
                                                                    ],
                                                                }),
                                                            ],
                                                            width: { size: 50, type: WidthType.PERCENTAGE },
                                                            borders: {
                                                                top: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
                                                                bottom: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
                                                                left: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
                                                                right: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
                                                            },
                                                        }),
                                                    ]
                                                    : []),
                                                ...(provider
                                                    ? [
                                                        new TableCell({
                                                            children: [
                                                                new Paragraph({
                                                                    children: [
                                                                        new TextRun({
                                                                            text: `Provider: ${provider}`,
                                                                            size: 16,
                                                                            color: "6B7280",
                                                                            font: "Arial",
                                                                        }),
                                                                    ],
                                                                    alignment: AlignmentType.RIGHT,
                                                                }),
                                                            ],
                                                            width: { size: 50, type: WidthType.PERCENTAGE },
                                                            borders: {
                                                                top: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
                                                                bottom: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
                                                                left: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
                                                                right: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
                                                            },
                                                        }),
                                                    ]
                                                    : []),
                                            ],
                                        }),
                                    ],
                                    width: { size: 100, type: WidthType.PERCENTAGE },
                                }),
                                // Spacer
                                new Paragraph({ spacing: { after: 200 } }),
                            ]
                            : []),

                        // Content paragraphs
                        ...paragraphs.map((line) => {
                            const trimmed = line.trim();

                            // Empty line → spacer
                            if (!trimmed) {
                                return new Paragraph({ spacing: { after: 100 } });
                            }

                            // Detect «guessed» words and highlight them
                            const children: TextRun[] = [];
                            const parts = trimmed.split(/(«[^»]+»)/g);
                            for (const part of parts) {
                                if (part.startsWith("«") && part.endsWith("»")) {
                                    // AI guessed word — highlight in amber
                                    children.push(
                                        new TextRun({
                                            text: part.slice(1, -1),
                                            color: "D97706",
                                            italics: true,
                                            underline: { type: "single", color: "D97706" },
                                            size: 22,
                                            font: "Arial",
                                        })
                                    );
                                } else {
                                    children.push(
                                        new TextRun({
                                            text: part,
                                            size: 22,
                                            color: "1F2937",
                                            font: "Arial",
                                        })
                                    );
                                }
                            }

                            return new Paragraph({
                                children,
                                spacing: { after: 80, line: 360 },
                            });
                        }),
                    ],
                },
            ],
        });

        const buffer = await Packer.toBuffer(doc);
        return Buffer.from(buffer);
    }
}
